# 前端性能的优化
## 资源合并和压缩

- 减少http请求数目，减少请求资源大小

   > 前端性能优化的核心是深入理解http请求的过程

    ![blockchain](1.png "http请求")
   - 了解浏览器的请求资源的过程

   - 了解可以在哪些地方可以优化

      - dns缓存减少dns查询时间

      - 网络的请求走最近的网环境（cdn）

      - 相同的静态资源的缓存

      - 减少http的大小

      - 减少http的请求

      - 服务端渲染

- 掌握压缩与合并的原理
   
   - 合并
   
        减少http的个数

   - 压缩

        减少http请求的大小
        
        - html的压缩：

          1.空格，回车等一些对浏览器没有意义的字符，但是这个压缩的效果量级较少，但是对于那些高访问的网站来说就很有价值。

          2.压缩方式：
          - 在线的压缩
          - node的提供的html-minifier工具
          - 后端模板渲染压缩
        - css的压缩

            1.无效代码的删除 ，css语意合并

            2.压缩方式：
            - 在线压缩
            - html-nimifier对css的压缩
            - 使用clear-css对css压缩
        - js的压缩和混乱

            1.无效的字符的删除，删除注释，代码语意的删减和优化，代码保护（代码的优化，代码的安全性 ）
        - 文件合并  

            文件合并能够有效的减少网络请求，同时还能获取数据的稳定性较少丢包的问题，但是文件合并还是有问题：1. 首屏渲染问题 2.缓存失效问题，合并后任意一个文件的高边都可能导致文件缓存失效的问题，解决方式：

            - 公共库打包成一个，业务代码打包成一个
            - 不同页面，单独打包
            - 见机行事，要针对不同的场景
            可以使用node,在线网站的文件合并，构建工具



- 在线网站和fis3的两种压缩合并
## 图片的相关优化

   - 图片优化的核心

       JPG:有损压缩，不支持透明

       png8/24/32的区别：

       - png8 256色 + 支持透明 ：小，但是颜色不丰富，表示一个颜色只需要8bit
       - png24 2^24 色 + 不支持透明
       - png32 2^24 色 + 支持透明 增加了8位来支持透明位

       webp ：压缩好，但是存在ios webview上有兼容问题

       svg矢量图：代码内嵌，图片相对简单的 

   - 图片的优化

        - 图片压缩 ：tinypng.com
        - 图片格式转化：将png,jpg转为webp,权衡base64的问题，inline-img
## css和js的加载

   - 渲染流程：

        ![blockchain](2.png "http请求")

   - 渲染特点

     - 顺序执行，并发加载：受到浏览器同一个域的并发加载限制，可以使用不同域名的保存资源

     - 是否阻塞

     - 依赖关系：使用async加载script资源的时候就失去了代码的依赖方式，defer的方式

     - 引入方式：单页面的按需加载

   - css阻塞

       css阻塞js执行，不阻塞脚本的加载，在head中的阻塞页面的渲染

   - js阻塞
           
      直接引入会阻塞页面的渲染，不阻塞资源的加载，顺序执行

   - 懒加载和预加载        

       懒加载：延迟加载----图片进入可视区域后请求图片资源，对于电商等图片多的场景很实用，同时可以减少无用资源的加载，减少页面阻塞，只有img的src属性被设置才去请求数据，图片的路径开始放在data-src一类的属性上，等到监听事件触发的时候才去设置src属性，这个时候就去获取图片数据

       预加载：提前加载 ---- 图片等静态资源在使用之前提前请求，能从缓存中读取，例如webgl的一些处理